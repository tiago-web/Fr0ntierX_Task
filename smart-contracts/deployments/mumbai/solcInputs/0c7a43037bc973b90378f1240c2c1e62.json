{
  "language": "Solidity",
  "sources": {
    "contracts/exchange/Exchange.sol": {
      "content": "/*\r\n\r\n  << Exchange >>\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"./ExchangeCore.sol\";\r\n\r\n/**\r\n * @title Exchange\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract Exchange is ExchangeCore {\r\n    /* external ABI-encodable method wrappers. */\r\n\r\n    function hashOrder_(\r\n        address registry,\r\n        address maker,\r\n        address staticTarget,\r\n        bytes4 staticSelector,\r\n        bytes calldata staticExtradata,\r\n        uint maximumFill,\r\n        uint listingTime,\r\n        uint expirationTime,\r\n        uint salt\r\n    ) external pure returns (bytes32 hash) {\r\n        return\r\n            hashOrder(\r\n                Order(\r\n                    registry,\r\n                    maker,\r\n                    staticTarget,\r\n                    staticSelector,\r\n                    staticExtradata,\r\n                    maximumFill,\r\n                    listingTime,\r\n                    expirationTime,\r\n                    salt\r\n                )\r\n            );\r\n    }\r\n\r\n    function hashToSign_(bytes32 orderHash)\r\n        external\r\n        view\r\n        returns (bytes32 hash)\r\n    {\r\n        return hashToSign(orderHash);\r\n    }\r\n\r\n    function validateOrderParameters_(\r\n        address registry,\r\n        address maker,\r\n        address staticTarget,\r\n        bytes4 staticSelector,\r\n        bytes calldata staticExtradata,\r\n        uint maximumFill,\r\n        uint listingTime,\r\n        uint expirationTime,\r\n        uint salt\r\n    ) external view returns (bool) {\r\n        Order memory order = Order(\r\n            registry,\r\n            maker,\r\n            staticTarget,\r\n            staticSelector,\r\n            staticExtradata,\r\n            maximumFill,\r\n            listingTime,\r\n            expirationTime,\r\n            salt\r\n        );\r\n        return validateOrderParameters(order, hashOrder(order));\r\n    }\r\n\r\n    function validateOrderAuthorization_(\r\n        bytes32 hash,\r\n        address maker,\r\n        bytes calldata signature\r\n    ) external view returns (bool) {\r\n        return validateOrderAuthorization(hash, maker, signature);\r\n    }\r\n\r\n    function approveOrderHash_(bytes32 hash) external {\r\n        return approveOrderHash(hash);\r\n    }\r\n\r\n    function approveOrder_(\r\n        address registry,\r\n        address maker,\r\n        address staticTarget,\r\n        bytes4 staticSelector,\r\n        bytes calldata staticExtradata,\r\n        uint maximumFill,\r\n        uint listingTime,\r\n        uint expirationTime,\r\n        uint salt,\r\n        bool orderbookInclusionDesired\r\n    ) external {\r\n        return\r\n            approveOrder(\r\n                Order(\r\n                    registry,\r\n                    maker,\r\n                    staticTarget,\r\n                    staticSelector,\r\n                    staticExtradata,\r\n                    maximumFill,\r\n                    listingTime,\r\n                    expirationTime,\r\n                    salt\r\n                ),\r\n                orderbookInclusionDesired\r\n            );\r\n    }\r\n\r\n    function setOrderFill_(bytes32 hash, uint fill) external {\r\n        return setOrderFill(hash, fill);\r\n    }\r\n\r\n    function atomicMatch_(\r\n        uint[16] memory uints,\r\n        bytes4[2] memory staticSelectors,\r\n        bytes memory firstExtradata,\r\n        bytes memory firstCalldata,\r\n        bytes memory secondExtradata,\r\n        bytes memory secondCalldata,\r\n        uint8[2] memory howToCalls,\r\n        bytes32 metadata,\r\n        bytes memory signatures\r\n    ) public payable {\r\n        return\r\n            atomicMatch(\r\n                Order(\r\n                    address(uints[0]),\r\n                    address(uints[1]),\r\n                    address(uints[2]),\r\n                    staticSelectors[0],\r\n                    firstExtradata,\r\n                    uints[3],\r\n                    uints[4],\r\n                    uints[5],\r\n                    uints[6]\r\n                ),\r\n                Call(\r\n                    address(uints[7]),\r\n                    AuthenticatedProxy.HowToCall(howToCalls[0]),\r\n                    firstCalldata\r\n                ),\r\n                Order(\r\n                    address(uints[8]),\r\n                    address(uints[9]),\r\n                    address(uints[10]),\r\n                    staticSelectors[1],\r\n                    secondExtradata,\r\n                    uints[11],\r\n                    uints[12],\r\n                    uints[13],\r\n                    uints[14]\r\n                ),\r\n                Call(\r\n                    address(uints[15]),\r\n                    AuthenticatedProxy.HowToCall(howToCalls[1]),\r\n                    secondCalldata\r\n                ),\r\n                signatures,\r\n                metadata\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/exchange/ExchangeCore.sol": {
      "content": "/*\r\n\r\n  << Exchange Core >>\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\r\n\r\nimport \"../lib/StaticCaller.sol\";\r\nimport \"../lib/ReentrancyGuarded.sol\";\r\nimport \"../lib/EIP712.sol\";\r\nimport \"../lib/EIP1271.sol\";\r\nimport \"../registry/ProxyRegistryInterface.sol\";\r\nimport \"../registry/AuthenticatedProxy.sol\";\r\n\r\n/**\r\n * @title ExchangeCore\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract ExchangeCore is ReentrancyGuarded, StaticCaller, EIP712 {\r\n\r\n    bytes4 constant internal EIP_1271_MAGICVALUE = 0x1626ba7e;\r\n    bytes internal personalSignPrefix = \"\\x19Ethereum Signed Message:\\n\";\r\n\r\n    /* Struct definitions. */\r\n\r\n    /* An order, convenience struct. */\r\n    struct Order {\r\n        /* Order registry address. */\r\n        address registry;\r\n        /* Order maker address. */\r\n        address maker;\r\n        /* Order static target. */\r\n        address staticTarget;\r\n        /* Order static selector. */\r\n        bytes4 staticSelector;\r\n        /* Order static extradata. */\r\n        bytes staticExtradata;\r\n        /* Order maximum fill factor. */\r\n        uint maximumFill;\r\n        /* Order listing timestamp. */\r\n        uint listingTime;\r\n        /* Order expiration timestamp - 0 for no expiry. */\r\n        uint expirationTime;\r\n        /* Order salt to prevent duplicate hashes. */\r\n        uint salt;\r\n    }\r\n\r\n    /* A call, convenience struct. */\r\n    struct Call {\r\n        /* Target */\r\n        address target;\r\n        /* How to call */\r\n        AuthenticatedProxy.HowToCall howToCall;\r\n        /* Calldata */\r\n        bytes data;\r\n    }\r\n\r\n    /* Constants */\r\n\r\n    /* Order typehash for EIP 712 compatibility. */\r\n    bytes32 constant ORDER_TYPEHASH = keccak256(\r\n        \"Order(address registry,address maker,address staticTarget,bytes4 staticSelector,bytes staticExtradata,uint256 maximumFill,uint256 listingTime,uint256 expirationTime,uint256 salt)\"\r\n    );\r\n\r\n    /* Variables */\r\n\r\n    /* Trusted proxy registry contracts. */\r\n    mapping(address => bool) public registries;\r\n\r\n    /* Order fill status, by maker address then by hash. */\r\n    mapping(address => mapping(bytes32 => uint)) public fills;\r\n\r\n    /* Orders verified by on-chain approval.\r\n       Alternative to ECDSA signatures so that smart contracts can place orders directly.\r\n       By maker address, then by hash. */\r\n    mapping(address => mapping(bytes32 => bool)) public approved;\r\n\r\n    /* Events */\r\n\r\n    event OrderApproved     (bytes32 indexed hash, address registry, address indexed maker, address staticTarget, bytes4 staticSelector, bytes staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt, bool orderbookInclusionDesired);\r\n    event OrderFillChanged  (bytes32 indexed hash, address indexed maker, uint newFill);\r\n    event OrdersMatched     (bytes32 firstHash, bytes32 secondHash, address indexed firstMaker, address indexed secondMaker, uint newFirstFill, uint newSecondFill, bytes32 indexed metadata);\r\n\r\n    /* Functions */\r\n\r\n    function hashOrder(Order memory order)\r\n        internal\r\n        pure\r\n        returns (bytes32 hash)\r\n    {\r\n        /* Per EIP 712. */\r\n        return keccak256(abi.encode(\r\n            ORDER_TYPEHASH,\r\n            order.registry,\r\n            order.maker,\r\n            order.staticTarget,\r\n            order.staticSelector,\r\n            keccak256(order.staticExtradata),\r\n            order.maximumFill,\r\n            order.listingTime,\r\n            order.expirationTime,\r\n            order.salt\r\n        ));\r\n    }\r\n\r\n    function hashToSign(bytes32 orderHash)\r\n        internal\r\n        view\r\n        returns (bytes32 hash)\r\n    {\r\n        /* Calculate the string a user must sign. */\r\n        return keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            orderHash\r\n        ));\r\n    }\r\n\r\n    function exists(address what)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(what)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function validateOrderParameters(Order memory order, bytes32 hash)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        /* Order must be listed and not be expired. */\r\n        if (order.listingTime > block.timestamp || (order.expirationTime != 0 && order.expirationTime <= block.timestamp)) {\r\n            return false;\r\n        }\r\n\r\n        /* Order must not have already been completely filled. */\r\n        if (fills[order.maker][hash] >= order.maximumFill) {\r\n            return false;\r\n        }\r\n\r\n        /* Order static target must exist. */\r\n        if (!exists(order.staticTarget)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function validateOrderAuthorization(bytes32 hash, address maker, bytes memory signature)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        /* Memoized authentication. If order has already been partially filled, order must be authenticated. */\r\n        if (fills[maker][hash] > 0) {\r\n            return true;\r\n        }\r\n\r\n        /* Order authentication. Order must be either: */\r\n\r\n        /* (a): sent by maker */\r\n        if (maker == msg.sender) {\r\n            return true;\r\n        }\r\n\r\n        /* (b): previously approved */\r\n        if (approved[maker][hash]) {\r\n            return true;\r\n        }\r\n\r\n        /* Calculate hash which must be signed. */\r\n        bytes32 calculatedHashToSign = hashToSign(hash);\r\n\r\n        /* Determine whether signer is a contract or account. */\r\n        bool isContract = exists(maker);\r\n\r\n        /* (c): Contract-only authentication: EIP/ERC 1271. */\r\n        if (isContract) {\r\n            if (ERC1271(maker).isValidSignature(calculatedHashToSign, signature) == EIP_1271_MAGICVALUE) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /* (d): Account-only authentication: ECDSA-signed by maker. */\r\n        (uint8 v, bytes32 r, bytes32 s) = abi.decode(signature, (uint8, bytes32, bytes32));\r\n\r\n        if (signature.length > 65 && signature[signature.length-1] == 0x03) { // EthSign byte\r\n            /* (d.1): Old way: order hash signed by maker using the prefixed personal_sign */\r\n            if (ecrecover(keccak256(abi.encodePacked(personalSignPrefix,\"32\",calculatedHashToSign)), v, r, s) == maker) {\r\n                return true;\r\n            }\r\n        }\r\n        /* (d.2): New way: order hash signed by maker using sign_typed_data */\r\n        else if (ecrecover(calculatedHashToSign, v, r, s) == maker) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function encodeStaticCall(Order memory order, Call memory call, Order memory counterorder, Call memory countercall, address matcher, uint value, uint fill)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        /* This array wrapping is necessary to preserve static call target function stack space. */\r\n        address[7] memory addresses = [order.registry, order.maker, call.target, counterorder.registry, counterorder.maker, countercall.target, matcher];\r\n        AuthenticatedProxy.HowToCall[2] memory howToCalls = [call.howToCall, countercall.howToCall];\r\n        uint[6] memory uints = [value, order.maximumFill, order.listingTime, order.expirationTime, counterorder.listingTime, fill];\r\n        return abi.encodeWithSelector(order.staticSelector, order.staticExtradata, addresses, howToCalls, uints, call.data, countercall.data);\r\n    }\r\n\r\n    function executeStaticCall(Order memory order, Call memory call, Order memory counterorder, Call memory countercall, address matcher, uint value, uint fill)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        return staticCallUint(order.staticTarget, encodeStaticCall(order, call, counterorder, countercall, matcher, value, fill));\r\n    }\r\n\r\n    function executeCall(ProxyRegistryInterface registry, address maker, Call memory call)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        /* Assert valid registry. */\r\n        require(registries[address(registry)]);\r\n\r\n        /* Assert target exists. */\r\n        require(exists(call.target), \"Call target does not exist\");\r\n\r\n        /* Retrieve delegate proxy contract. */\r\n        OwnableDelegateProxy delegateProxy = registry.proxies(maker);\r\n\r\n        /* Assert existence. */\r\n        require(delegateProxy != OwnableDelegateProxy(0), \"Delegate proxy does not exist for maker\");\r\n\r\n        /* Assert implementation. */\r\n        require(delegateProxy.implementation() == registry.delegateProxyImplementation(), \"Incorrect delegate proxy implementation for maker\");\r\n\r\n        /* Typecast. */\r\n        AuthenticatedProxy proxy = AuthenticatedProxy(address(delegateProxy));\r\n\r\n        /* Execute order. */\r\n        return proxy.proxy(call.target, call.howToCall, call.data);\r\n    }\r\n\r\n    function approveOrderHash(bytes32 hash)\r\n        internal\r\n    {\r\n        /* CHECKS */\r\n\r\n        /* Assert order has not already been approved. */\r\n        require(!approved[msg.sender][hash], \"Order has already been approved\");\r\n\r\n        /* EFFECTS */\r\n\r\n        /* Mark order as approved. */\r\n        approved[msg.sender][hash] = true;\r\n    }\r\n\r\n    function approveOrder(Order memory order, bool orderbookInclusionDesired)\r\n        internal\r\n    {\r\n        /* CHECKS */\r\n\r\n        /* Assert sender is authorized to approve order. */\r\n        require(order.maker == msg.sender, \"Sender is not the maker of the order and thus not authorized to approve it\");\r\n\r\n        /* Calculate order hash. */\r\n        bytes32 hash = hashOrder(order);\r\n\r\n        /* Approve order hash. */\r\n        approveOrderHash(hash);\r\n\r\n        /* Log approval event. */\r\n        emit OrderApproved(hash, order.registry, order.maker, order.staticTarget, order.staticSelector, order.staticExtradata, order.maximumFill, order.listingTime, order.expirationTime, order.salt, orderbookInclusionDesired);\r\n    }\r\n\r\n    function setOrderFill(bytes32 hash, uint fill)\r\n        internal\r\n    {\r\n        /* CHECKS */\r\n\r\n        /* Assert fill is not already set. */\r\n        require(fills[msg.sender][hash] != fill, \"Fill is already set to the desired value\");\r\n\r\n        /* EFFECTS */\r\n\r\n        /* Mark order as accordingly filled. */\r\n        fills[msg.sender][hash] = fill;\r\n\r\n        /* Log order fill change event. */\r\n        emit OrderFillChanged(hash, msg.sender, fill);\r\n    }\r\n\r\n    function atomicMatch(Order memory firstOrder, Call memory firstCall, Order memory secondOrder, Call memory secondCall, bytes memory signatures, bytes32 metadata)\r\n        internal\r\n        reentrancyGuard\r\n    {\r\n        /* CHECKS */\r\n\r\n        /* Calculate first order hash. */\r\n        bytes32 firstHash = hashOrder(firstOrder);\r\n\r\n        /* Check first order validity. */\r\n        require(validateOrderParameters(firstOrder, firstHash), \"First order has invalid parameters\");\r\n\r\n        /* Calculate second order hash. */\r\n        bytes32 secondHash = hashOrder(secondOrder);\r\n\r\n        /* Check second order validity. */\r\n        require(validateOrderParameters(secondOrder, secondHash), \"Second order has invalid parameters\");\r\n\r\n        /* Prevent self-matching (possibly unnecessary, but safer). */\r\n        require(firstHash != secondHash, \"Self-matching orders is prohibited\");\r\n\r\n        {\r\n            /* Calculate signatures (must be awkwardly decoded here due to stack size constraints). */\r\n            (bytes memory firstSignature, bytes memory secondSignature) = abi.decode(signatures, (bytes, bytes));\r\n\r\n            /* Check first order authorization. */\r\n            require(validateOrderAuthorization(firstHash, firstOrder.maker, firstSignature), \"First order failed authorization\");\r\n\r\n            /* Check second order authorization. */\r\n            require(validateOrderAuthorization(secondHash, secondOrder.maker, secondSignature), \"Second order failed authorization\");\r\n        }\r\n\r\n        /* INTERACTIONS */\r\n\r\n        /* Transfer any msg.value.\r\n           This is the first \"asymmetric\" part of order matching: if an order requires Ether, it must be the first order. */\r\n        if (msg.value > 0) {\r\n            /* Reentrancy prevented by reentrancyGuard modifier */\r\n            (bool success,) = address(uint160(firstOrder.maker)).call{value: msg.value}(\"\");\r\n            require(success, \"native token transfer failed.\");\r\n        }\r\n\r\n        /* Execute first call, assert success.\r\n           This is the second \"asymmetric\" part of order matching: execution of the second order can depend on state changes in the first order, but not vice-versa. */\r\n        require(executeCall(ProxyRegistryInterface(firstOrder.registry), firstOrder.maker, firstCall), \"First call failed\");\r\n\r\n        /* Execute second call, assert success. */\r\n        require(executeCall(ProxyRegistryInterface(secondOrder.registry), secondOrder.maker, secondCall), \"Second call failed\");\r\n\r\n        /* Static calls must happen after the effectful calls so that they can check the resulting state. */\r\n\r\n        /* Fetch previous first order fill. */\r\n        uint previousFirstFill = fills[firstOrder.maker][firstHash];\r\n\r\n        /* Fetch previous second order fill. */\r\n        uint previousSecondFill = fills[secondOrder.maker][secondHash];\r\n\r\n        /* Execute first order static call, assert success, capture returned new fill. */\r\n        uint firstFill = executeStaticCall(firstOrder, firstCall, secondOrder, secondCall, msg.sender, msg.value, previousFirstFill);\r\n\r\n        /* Execute second order static call, assert success, capture returned new fill. */\r\n        uint secondFill = executeStaticCall(secondOrder, secondCall, firstOrder, firstCall, msg.sender, uint(0), previousSecondFill);\r\n\r\n        /* EFFECTS */\r\n\r\n        /* Update first order fill, if necessary. */\r\n        if (firstOrder.maker != msg.sender) {\r\n            if (firstFill != previousFirstFill) {\r\n                fills[firstOrder.maker][firstHash] = firstFill;\r\n            }\r\n        }\r\n\r\n        /* Update second order fill, if necessary. */\r\n        if (secondOrder.maker != msg.sender) {\r\n            if (secondFill != previousSecondFill) {\r\n                fills[secondOrder.maker][secondHash] = secondFill;\r\n            }\r\n        }\r\n\r\n        /* LOGS */\r\n\r\n        /* Log match event. */\r\n        emit OrdersMatched(firstHash, secondHash, firstOrder.maker, secondOrder.maker, firstFill, secondFill, metadata);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/lib/StaticCaller.sol": {
      "content": "/*\r\n\r\n  << Static Caller >>\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\n/**\r\n * @title StaticCaller\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract StaticCaller {\r\n\r\n    function staticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bool result)\r\n    {\r\n        assembly {\r\n            result := staticcall(gas(), target, add(data, 0x20), mload(data), mload(0x40), 0)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function staticCallUint(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (uint ret)\r\n    {\r\n        bool result;\r\n        assembly {\r\n            let size := 0x20\r\n            let free := mload(0x40)\r\n            result := staticcall(gas(), target, add(data, 0x20), mload(data), free, size)\r\n            ret := mload(free)\r\n        }\r\n        require(result, \"Static call failed\");\r\n        return ret;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/lib/ReentrancyGuarded.sol": {
      "content": "/*\r\n\r\n  Simple contract extension to provide a contract-global reentrancy guard on functions.\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\n/**\r\n * @title ReentrancyGuarded\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract ReentrancyGuarded {\r\n\r\n    bool reentrancyLock = false;\r\n\r\n    /* Prevent a contract function from being reentrant-called. */\r\n    modifier reentrancyGuard {\r\n        require(!reentrancyLock, \"Reentrancy detected\");\r\n        reentrancyLock = true;\r\n        _;\r\n        reentrancyLock = false;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/lib/EIP712.sol": {
      "content": "/*\r\n\r\n  << EIP 712 >>\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\n/**\r\n * @title EIP712\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract EIP712 {\r\n\r\n    struct EIP712Domain {\r\n        string  name;\r\n        string  version;\r\n        uint256 chainId;\r\n        address verifyingContract;\r\n    }\r\n\r\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    bytes32 DOMAIN_SEPARATOR;\r\n\r\n    function hash(EIP712Domain memory eip712Domain)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(bytes(eip712Domain.name)),\r\n            keccak256(bytes(eip712Domain.version)),\r\n            eip712Domain.chainId,\r\n            eip712Domain.verifyingContract\r\n        ));\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/lib/EIP1271.sol": {
      "content": "/*\r\n\r\n  << EIP 1271 >>\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nabstract contract ERC1271 {\r\n\r\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n  bytes4 constant internal MAGICVALUE = 0x1626ba7e;\r\n\r\n  /**\r\n   * @dev Should return whether the signature provided is valid for the provided hash\r\n   * @param _hash      Hash of the data to be signed\r\n   * @param _signature Signature byte array associated with _hash\r\n   *\r\n   * MUST return the bytes4 magic value 0x1626ba7e when function passes.\r\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n   * MUST allow external calls\r\n   */ \r\n  function isValidSignature(\r\n    bytes32 _hash, \r\n    bytes memory _signature)\r\n    virtual\r\n    public\r\n    view \r\n    returns (bytes4 magicValue);\r\n}"
    },
    "contracts/registry/ProxyRegistryInterface.sol": {
      "content": "/*\r\n\r\n  Proxy registry interface.\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"./OwnableDelegateProxy.sol\";\r\n\r\n/**\r\n * @title ProxyRegistryInterface\r\n * @author Wyvern Protocol Developers\r\n */\r\ninterface ProxyRegistryInterface {\r\n\r\n    function delegateProxyImplementation() external returns (address);\r\n\r\n    function proxies(address owner) external returns (OwnableDelegateProxy);\r\n\r\n}\r\n"
    },
    "contracts/registry/AuthenticatedProxy.sol": {
      "content": "/* \r\n\r\n  Proxy contract to hold access to assets on behalf of a user (e.g. ERC20 approve) and execute calls under particular conditions.\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"./ProxyRegistry.sol\";\r\nimport \"./TokenRecipient.sol\";\r\nimport \"./proxy/OwnedUpgradeabilityStorage.sol\";\r\n\r\n/**\r\n * @title AuthenticatedProxy\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract AuthenticatedProxy is TokenRecipient, OwnedUpgradeabilityStorage {\r\n\r\n    /* Whether initialized. */\r\n    bool initialized = false;\r\n\r\n    /* Address which owns this proxy. */\r\n    address public user;\r\n\r\n    /* Associated registry with contract authentication information. */\r\n    ProxyRegistry public registry;\r\n\r\n    /* Whether access has been revoked. */\r\n    bool public revoked;\r\n\r\n    /* Delegate call could be used to atomically transfer multiple assets owned by the proxy contract with one order. */\r\n    enum HowToCall { Call, DelegateCall }\r\n\r\n    /* Event fired when the proxy access is revoked or unrevoked. */\r\n    event Revoked(bool revoked);\r\n\r\n    /**\r\n     * Initialize an AuthenticatedProxy\r\n     *\r\n     * @param addrUser Address of user on whose behalf this proxy will act\r\n     * @param addrRegistry Address of ProxyRegistry contract which will manage this proxy\r\n     */\r\n    function initialize (address addrUser, ProxyRegistry addrRegistry)\r\n        public\r\n    {\r\n        require(!initialized, \"Authenticated proxy already initialized\");\r\n        initialized = true;\r\n        user = addrUser;\r\n        registry = addrRegistry;\r\n    }\r\n\r\n    /**\r\n     * Set the revoked flag (allows a user to revoke ProxyRegistry access)\r\n     *\r\n     * @dev Can be called by the user only\r\n     * @param revoke Whether or not to revoke access\r\n     */\r\n    function setRevoke(bool revoke)\r\n        public\r\n    {\r\n        require(msg.sender == user, \"Authenticated proxy can only be revoked by its user\");\r\n        revoked = revoke;\r\n        emit Revoked(revoke);\r\n    }\r\n\r\n    /**\r\n     * Execute a message call from the proxy contract\r\n     *\r\n     * @dev Can be called by the user, or by a contract authorized by the registry as long as the user has not revoked access\r\n     * @param dest Address to which the call will be sent\r\n     * @param howToCall Which kind of call to make\r\n     * @param data Calldata to send\r\n     * @return result Result of the call (success or failure)\r\n     */\r\n    function proxy(address dest, HowToCall howToCall, bytes memory data)\r\n        public\r\n        returns (bool result)\r\n    {\r\n        require(msg.sender == user || (!revoked && registry.contracts(msg.sender)), \"Authenticated proxy can only be called by its user, or by a contract authorized by the registry as long as the user has not revoked access\");\r\n        bytes memory ret;\r\n        if (howToCall == HowToCall.Call) {\r\n            (result, ret) = dest.call(data);\r\n        } else if (howToCall == HowToCall.DelegateCall) {\r\n            (result, ret) = dest.delegatecall(data);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Execute a message call and assert success\r\n     * \r\n     * @dev Same functionality as `proxy`, just asserts the return value\r\n     * @param dest Address to which the call will be sent\r\n     * @param howToCall What kind of call to make\r\n     * @param data Calldata to send\r\n     */\r\n    function proxyAssert(address dest, HowToCall howToCall, bytes memory data)\r\n        public\r\n    {\r\n        require(proxy(dest, howToCall, data), \"Proxy assertion failed\");\r\n    }\r\n\r\n}\r\n"
    },
    "openzeppelin-solidity/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/registry/OwnableDelegateProxy.sol": {
      "content": "/*\r\n\r\n  OwnableDelegateProxy\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"./proxy/OwnedUpgradeabilityProxy.sol\";\r\n\r\n/**\r\n * @title OwnableDelegateProxy\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract OwnableDelegateProxy is OwnedUpgradeabilityProxy {\r\n\r\n    constructor(address owner, address initialImplementation, bytes memory data)\r\n        public\r\n    {\r\n        setUpgradeabilityOwner(owner);\r\n        _upgradeTo(initialImplementation);\r\n        (bool success,) = initialImplementation.delegatecall(data);\r\n        require(success, \"OwnableDelegateProxy failed implementation\");\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/registry/proxy/OwnedUpgradeabilityProxy.sol": {
      "content": "pragma solidity 0.7.5;\r\n\r\nimport \"./Proxy.sol\";\r\nimport \"./OwnedUpgradeabilityStorage.sol\";\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is Proxy, OwnedUpgradeabilityStorage {\r\n    /**\r\n     * @dev Event to show ownership has been transferred\r\n     * @param previousOwner representing the address of the previous owner\r\n     * @param newOwner representing the address of the new owner\r\n     */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n     * @dev This event will be emitted every time the implementation gets upgraded\r\n     * @param implementation representing the address of the upgraded implementation\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Tells the address of the current implementation\r\n     * @return address of the current implementation\r\n     */\r\n    function implementation() override public view returns (address) {\r\n        return _implementation;\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the proxy type (EIP 897)\r\n     * @return proxyTypeId Proxy type, 2 for forwarding proxy\r\n     */\r\n    function proxyType() override public pure returns (uint256 proxyTypeId) {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades the implementation address\r\n     * @param implementation representing the address of the new implementation to be set\r\n     */\r\n    function _upgradeTo(address implementation) internal {\r\n        require(_implementation != implementation, \"Proxy already uses this implementation\");\r\n        _implementation = implementation;\r\n        emit Upgraded(implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner(), \"Only the proxy owner can call this method\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the proxy owner\r\n     * @return the address of the proxy owner\r\n     */\r\n    function proxyOwner() public view returns (address) {\r\n        return upgradeabilityOwner();\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\r\n        require(newOwner != address(0), \"New owner cannot be the null address\");\r\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\r\n        setUpgradeabilityOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the upgradeability owner to upgrade the current implementation of the proxy.\r\n     * @param implementation representing the address of the new implementation to be set.\r\n     */\r\n    function upgradeTo(address implementation) public onlyProxyOwner {\r\n        _upgradeTo(implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the upgradeability owner to upgrade the current implementation of the proxy\r\n     * and delegatecall the new implementation for initialization.\r\n     * @param implementation representing the address of the new implementation to be set.\r\n     * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n     * signature of the implementation to be called with the needed payload\r\n     */\r\n    function upgradeToAndCall(address implementation, bytes memory data) payable public onlyProxyOwner {\r\n        upgradeTo(implementation);\r\n        (bool success,) = address(this).delegatecall(data);\r\n        require(success, \"Call failed after proxy upgrade\");\r\n    }\r\n}\r\n"
    },
    "contracts/registry/proxy/Proxy.sol": {
      "content": "pragma solidity 0.7.5;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Tells the address of the implementation where every call will be delegated.\r\n     * @return address of the implementation to which it will be delegated\r\n     */\r\n    function implementation() virtual public view returns (address);\r\n\r\n    /**\r\n     * @dev Tells the type of proxy (EIP 897)\r\n     * @return proxyTypeId Type of proxy, 2 for upgradeable proxy\r\n     */\r\n    function proxyType() virtual public pure returns (uint256 proxyTypeId);\r\n\r\n    /**\r\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n     * This function will return whatever the implementation call returns\r\n     */\r\n    fallback () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0), \"Proxy implementation required\");\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/registry/proxy/OwnedUpgradeabilityStorage.sol": {
      "content": "pragma solidity 0.7.5;\r\n\r\n/**\r\n * @title OwnedUpgradeabilityStorage\r\n * @dev This contract keeps track of the upgradeability owner\r\n */\r\ncontract OwnedUpgradeabilityStorage {\r\n\r\n    // Current implementation\r\n    address internal _implementation;\r\n\r\n    // Owner of the contract\r\n    address private _upgradeabilityOwner;\r\n\r\n    /**\r\n     * @dev Tells the address of the owner\r\n     * @return the address of the owner\r\n     */\r\n    function upgradeabilityOwner() public view returns (address) {\r\n        return _upgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n     */\r\n    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\r\n        _upgradeabilityOwner = newUpgradeabilityOwner;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/registry/ProxyRegistry.sol": {
      "content": "/*\r\n\r\n  Proxy registry; keeps a mapping of AuthenticatedProxy contracts and mapping of contracts authorized to access them.  \r\n  \r\n  Abstracted away from the Exchange (a) to reduce Exchange attack surface and (b) so that the Exchange contract can be upgraded without users needing to transfer assets to new proxies.\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\r\n\r\nimport \"./OwnableDelegateProxy.sol\";\r\nimport \"./ProxyRegistryInterface.sol\";\r\n\r\n/**\r\n * @title ProxyRegistry\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract ProxyRegistry is Ownable, ProxyRegistryInterface {\r\n\r\n    /* DelegateProxy implementation contract. Must be initialized. */\r\n    address public override delegateProxyImplementation;\r\n\r\n    /* Authenticated proxies by user. */\r\n    mapping(address => OwnableDelegateProxy) public override proxies;\r\n\r\n    /* Contracts pending access. */\r\n    mapping(address => uint) public pending;\r\n\r\n    /* Contracts allowed to call those proxies. */\r\n    mapping(address => bool) public contracts;\r\n\r\n    /* Delay period for adding an authenticated contract.\r\n       This mitigates a particular class of potential attack on the Wyvern DAO (which owns this registry) - if at any point the value of assets held by proxy contracts exceeded the value of half the WYV supply (votes in the DAO),\r\n       a malicious but rational attacker could buy half the Wyvern and grant themselves access to all the proxy contracts. A delay period renders this attack nonthreatening - given two weeks, if that happened, users would have\r\n       plenty of time to notice and transfer their assets.\r\n    */\r\n    uint public DELAY_PERIOD = 2 weeks;\r\n\r\n    /**\r\n     * Start the process to enable access for specified contract. Subject to delay period.\r\n     *\r\n     * @dev ProxyRegistry owner only\r\n     * @param addr Address to which to grant permissions\r\n     */\r\n    function startGrantAuthentication (address addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(!contracts[addr] && pending[addr] == 0, \"Contract is already allowed in registry, or pending\");\r\n        pending[addr] = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * End the process to enable access for specified contract after delay period has passed.\r\n     *\r\n     * @dev ProxyRegistry owner only\r\n     * @param addr Address to which to grant permissions\r\n     */\r\n    function endGrantAuthentication (address addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(!contracts[addr] && pending[addr] != 0 && ((pending[addr] + DELAY_PERIOD) < block.timestamp), \"Contract is no longer pending or has already been approved by registry\");\r\n        pending[addr] = 0;\r\n        contracts[addr] = true;\r\n    }\r\n\r\n    /**\r\n     * Revoke access for specified contract. Can be done instantly.\r\n     *\r\n     * @dev ProxyRegistry owner only\r\n     * @param addr Address of which to revoke permissions\r\n     */    \r\n    function revokeAuthentication (address addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        contracts[addr] = false;\r\n    }\r\n\r\n    /**\r\n     * Register a proxy contract with this registry\r\n     *\r\n     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\r\n     * @return proxy New AuthenticatedProxy contract\r\n     */\r\n    function registerProxy()\r\n        public\r\n        returns (OwnableDelegateProxy proxy)\r\n    {\r\n        return registerProxyFor(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Register a proxy contract with this registry, overriding any existing proxy\r\n     *\r\n     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\r\n     * @return proxy New AuthenticatedProxy contract\r\n     */\r\n    function registerProxyOverride()\r\n        public\r\n        returns (OwnableDelegateProxy proxy)\r\n    {\r\n        proxy = new OwnableDelegateProxy(msg.sender, delegateProxyImplementation, abi.encodeWithSignature(\"initialize(address,address)\", msg.sender, address(this)));\r\n        proxies[msg.sender] = proxy;\r\n        return proxy;\r\n    }\r\n\r\n    /**\r\n     * Register a proxy contract with this registry\r\n     *\r\n     * @dev Can be called by any user\r\n     * @return proxy New AuthenticatedProxy contract\r\n     */\r\n    function registerProxyFor(address user)\r\n        public\r\n        returns (OwnableDelegateProxy proxy)\r\n    {\r\n        require(proxies[user] == OwnableDelegateProxy(0), \"User already has a proxy\");\r\n        proxy = new OwnableDelegateProxy(user, delegateProxyImplementation, abi.encodeWithSignature(\"initialize(address,address)\", user, address(this)));\r\n        proxies[user] = proxy;\r\n        return proxy;\r\n    }\r\n\r\n    /**\r\n     * Transfer access\r\n     */\r\n    function transferAccessTo(address from, address to)\r\n        public\r\n    {\r\n        OwnableDelegateProxy proxy = proxies[from];\r\n\r\n        /* CHECKS */\r\n        require(OwnableDelegateProxy(msg.sender) == proxy, \"Proxy transfer can only be called by the proxy\");\r\n        require(proxies[to] == OwnableDelegateProxy(0), \"Proxy transfer has existing proxy as destination\");\r\n\r\n        /* EFFECTS */\r\n        delete proxies[from];\r\n        proxies[to] = proxy;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/registry/TokenRecipient.sol": {
      "content": "/*\r\n\r\n  Token recipient. Modified very slightly from the example on http://ethereum.org/dao (just to index log parameters).\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @title TokenRecipient\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract TokenRecipient {\r\n    event ReceivedEther(address indexed sender, uint amount);\r\n    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);\r\n\r\n    /**\r\n     * @dev Receive tokens and generate a log event\r\n     * @param from Address from which to transfer tokens\r\n     * @param value Amount of tokens to transfer\r\n     * @param token Address of token\r\n     * @param extraData Additional data to log\r\n     */\r\n    function receiveApproval(address from, uint256 value, address token, bytes memory extraData) public {\r\n        ERC20 t = ERC20(token);\r\n        require(t.transferFrom(from, address(this), value), \"ERC20 token transfer failed\");\r\n        emit ReceivedTokens(from, value, token, extraData);\r\n    }\r\n\r\n    /**\r\n     * @dev Receive Ether and generate a log event\r\n     */\r\n    fallback () payable external {\r\n        emit ReceivedEther(msg.sender, msg.value);\r\n    }\r\n}\r\n"
    },
    "openzeppelin-solidity/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/WyvernExchange.sol": {
      "content": "/*\r\n\r\n  << Wyvern Exchange >>\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"./exchange/Exchange.sol\";\r\n\r\n/**\r\n * @title WyvernExchange\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract WyvernExchange is Exchange {\r\n\r\n    string public constant name = \"Wyvern Exchange\";\r\n  \r\n    string public constant version = \"3.1\";\r\n\r\n    string public constant codename = \"Ancalagon\";\r\n\r\n    constructor (uint chainId, address[] memory registryAddrs, bytes memory customPersonalSignPrefix) public {\r\n        DOMAIN_SEPARATOR = hash(EIP712Domain({\r\n            name              : name,\r\n            version           : version,\r\n            chainId           : chainId,\r\n            verifyingContract : address(this)\r\n        }));\r\n        for (uint ind = 0; ind < registryAddrs.length; ind++) {\r\n          registries[registryAddrs[ind]] = true;\r\n        }\r\n        if (customPersonalSignPrefix.length > 0) {\r\n          personalSignPrefix = customPersonalSignPrefix;\r\n        }\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/static/StaticERC721.sol": {
      "content": "/*\r\n\r\n    StaticERC721 - static calls for ERC721 trades\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\r\n\r\nimport \"../lib/ArrayUtils.sol\";\r\nimport \"../registry/AuthenticatedProxy.sol\";\r\n\r\ncontract StaticERC721 {\r\n\r\n    function transferERC721Exact(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory,\r\n        bytes memory data)\r\n        public\r\n        pure\r\n    {\r\n        // Decode extradata\r\n        (address token, uint tokenId) = abi.decode(extra, (address, uint));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == token);\r\n        // Call type = call\r\n        require(howToCall == AuthenticatedProxy.HowToCall.Call);\r\n        // Assert calldata\r\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], tokenId)));\r\n    }\r\n\r\n    function swapOneForOneERC721(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n        bytes memory data, bytes memory counterdata)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // Zero-value\r\n        require(uints[0] == 0);\r\n\r\n        // Decode extradata\r\n        (address[2] memory tokenGiveGet, uint[2] memory nftGiveGet) = abi.decode(extra, (address[2],uint[2]));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == tokenGiveGet[0], \"ERC721: call target must equal address of token to give\");\r\n        // Call type = call\r\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC721: call must be a direct call\");\r\n        // Assert calldata\r\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], nftGiveGet[0])));\r\n\r\n        // Countercall target = token to get\r\n        require(addresses[5] == tokenGiveGet[1], \"ERC721: countercall target must equal address of token to get\");\r\n        // Countercall type = call\r\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call, \"ERC721: countercall must be a direct call\");\r\n        // Assert countercalldata\r\n        require(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[4], addresses[1], nftGiveGet[1])));\r\n\r\n        // Mark filled\r\n        return 1;\r\n    }\r\n\r\n    function swapOneForOneERC721Decoding(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n        bytes memory data, bytes memory counterdata)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // Calculate function signature\r\n        bytes memory sig = ArrayUtils.arrayTake(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\"), 4);\r\n\r\n        // Zero-value\r\n        require(uints[0] == 0);\r\n\r\n        // Decode extradata\r\n        (address[2] memory tokenGiveGet, uint[2] memory nftGiveGet) = abi.decode(extra, (address[2],uint[2]));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == tokenGiveGet[0], \"ERC721: call target must equal address of token to give\");\r\n        // Call type = call\r\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC721: call must be a direct call\");\r\n        // Assert signature\r\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(data, 4)));\r\n        // Decode calldata\r\n        (address callFrom, address callTo, uint256 nftGive) = abi.decode(ArrayUtils.arrayDrop(data, 4), (address, address, uint256));\r\n        // Assert from\r\n        require(callFrom == addresses[1]);\r\n        // Assert to\r\n        require(callTo == addresses[4]);\r\n        // Assert NFT\r\n        require(nftGive == nftGiveGet[0]);\r\n\r\n        // Countercall target = token to get\r\n        require(addresses[5] == tokenGiveGet[1], \"ERC721: countercall target must equal address of token to get\");\r\n        // Countercall type = call\r\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call, \"ERC721: countercall must be a direct call\");\r\n        // Assert signature\r\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(counterdata, 4)));\r\n        // Decode countercalldata\r\n        (address countercallFrom, address countercallTo, uint256 nftGet) = abi.decode(ArrayUtils.arrayDrop(counterdata, 4), (address, address, uint256));\r\n        // Assert from\r\n        require(countercallFrom == addresses[4]);\r\n        // Assert to\r\n        require(countercallTo == addresses[1]);\r\n        // Assert NFT\r\n        require(nftGet == nftGiveGet[1]);\r\n\r\n        // Mark filled\r\n        return 1;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/lib/ArrayUtils.sol": {
      "content": "/*\r\n\r\n  << ArrayUtils >>\r\n\r\n  Various functions for manipulating arrays in Solidity.\r\n  This library is completely inlined and does not need to be deployed or linked.\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\r\n\r\n/**\r\n * @title ArrayUtils\r\n * @author Wyvern Protocol Developers\r\n */\r\nlibrary ArrayUtils {\r\n\r\n    /**\r\n     * Replace bytes in an array with bytes in another array, guarded by a bitmask\r\n     * Efficiency of this function is a bit unpredictable because of the EVM's word-specific model (arrays under 32 bytes will be slower)\r\n     * Modifies the provided byte array parameter in place\r\n     * \r\n     * @dev Mask must be the size of the byte array. A nonzero byte means the byte array can be changed.\r\n     * @param array The original array\r\n     * @param desired The target array\r\n     * @param mask The mask specifying which bits can be changed\r\n     */\r\n    function guardedArrayReplace(bytes memory array, bytes memory desired, bytes memory mask)\r\n        internal\r\n        pure\r\n    {\r\n        require(array.length == desired.length, \"Arrays have different lengths\");\r\n        require(array.length == mask.length, \"Array and mask have different lengths\");\r\n\r\n        uint words = array.length / 0x20;\r\n        uint index = words * 0x20;\r\n        assert(index / 0x20 == words);\r\n        uint i;\r\n\r\n        for (i = 0; i < words; i++) {\r\n            /* Conceptually: array[i] = (!mask[i] && array[i]) || (mask[i] && desired[i]), bitwise in word chunks. */\r\n            assembly {\r\n                let commonIndex := mul(0x20, add(1, i))\r\n                let maskValue := mload(add(mask, commonIndex))\r\n                mstore(add(array, commonIndex), or(and(not(maskValue), mload(add(array, commonIndex))), and(maskValue, mload(add(desired, commonIndex)))))\r\n            }\r\n        }\r\n\r\n        /* Deal with the last section of the byte array. */\r\n        if (words > 0) {\r\n            /* This overlaps with bytes already set but is still more efficient than iterating through each of the remaining bytes individually. */\r\n            i = words;\r\n            assembly {\r\n                let commonIndex := mul(0x20, add(1, i))\r\n                let maskValue := mload(add(mask, commonIndex))\r\n                mstore(add(array, commonIndex), or(and(not(maskValue), mload(add(array, commonIndex))), and(maskValue, mload(add(desired, commonIndex)))))\r\n            }\r\n        } else {\r\n            /* If the byte array is shorter than a word, we must unfortunately do the whole thing bytewise.\r\n               (bounds checks could still probably be optimized away in assembly, but this is a rare case) */\r\n            for (i = index; i < array.length; i++) {\r\n                array[i] = ((mask[i] ^ 0xff) & array[i]) | (mask[i] & desired[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test if two arrays are equal\r\n     * Source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n     * \r\n     * @dev Arrays must be of equal length, otherwise will return false\r\n     * @param a First array\r\n     * @param b Second array\r\n     * @return Whether or not all bytes in the arrays are equal\r\n     */\r\n    function arrayEq(bytes memory a, bytes memory b)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(a)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(b))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(a, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(b, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * Drop the beginning of an array\r\n     *\r\n     * @param _bytes array\r\n     * @param _start start index\r\n     * @return Whether or not all bytes in the arrays are equal\r\n     */\r\n    function arrayDrop(bytes memory _bytes, uint _start)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n\r\n        uint _length = SafeMath.sub(_bytes.length, _start);\r\n        return arraySlice(_bytes, _start, _length);\r\n    }\r\n\r\n    /**\r\n     * Take from the beginning of an array\r\n     *\r\n     * @param _bytes array\r\n     * @param _length elements to take\r\n     * @return Whether or not all bytes in the arrays are equal\r\n     */\r\n    function arrayTake(bytes memory _bytes, uint _length)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n\r\n        return arraySlice(_bytes, 0, _length);\r\n    }\r\n\r\n    /**\r\n     * Slice an array\r\n     * Source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n     *\r\n     * @param _bytes array\r\n     * @param _start start index\r\n     * @param _length length to take\r\n     * @return Whether or not all bytes in the arrays are equal\r\n     */\r\n    function arraySlice(bytes memory _bytes, uint _start, uint _length)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    /**\r\n     * Unsafe write byte array into a memory location\r\n     *\r\n     * @param index Memory location\r\n     * @param source Byte array to write\r\n     * @return End memory index\r\n     */\r\n    function unsafeWriteBytes(uint index, bytes memory source)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (source.length > 0) {\r\n            assembly {\r\n                let length := mload(source)\r\n                let end := add(source, add(0x20, length))\r\n                let arrIndex := add(source, 0x20)\r\n                let tempIndex := index\r\n                for { } eq(lt(arrIndex, end), 1) {\r\n                    arrIndex := add(arrIndex, 0x20)\r\n                    tempIndex := add(tempIndex, 0x20)\r\n                } {\r\n                    mstore(tempIndex, mload(arrIndex))\r\n                }\r\n                index := add(index, length)\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Unsafe write address into a memory location\r\n     *\r\n     * @param index Memory location\r\n     * @param source Address to write\r\n     * @return End memory index\r\n     */\r\n    function unsafeWriteAddress(uint index, address source)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        uint conv = uint(source) << 0x60;\r\n        assembly {\r\n            mstore(index, conv)\r\n            index := add(index, 0x14)\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Unsafe write uint into a memory location\r\n     *\r\n     * @param index Memory location\r\n     * @param source uint to write\r\n     * @return End memory index\r\n     */\r\n    function unsafeWriteUint(uint index, uint source)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        assembly {\r\n            mstore(index, source)\r\n            index := add(index, 0x20)\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Unsafe write uint8 into a memory location\r\n     *\r\n     * @param index Memory location\r\n     * @param source uint8 to write\r\n     * @return End memory index\r\n     */\r\n    function unsafeWriteUint8(uint index, uint8 source)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        assembly {\r\n            mstore8(index, source)\r\n            index := add(index, 0x1)\r\n        }\r\n        return index;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/WyvernStatic.sol": {
      "content": "/*\r\n\r\n  << Wyvern Static >>\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"./static/StaticERC20.sol\";\r\nimport \"./static/StaticERC721.sol\";\r\nimport \"./static/StaticERC1155.sol\";\r\nimport \"./static/StaticUtil.sol\";\r\n\r\n/**\r\n * @title WyvernStatic\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract WyvernStatic is StaticERC20, StaticERC721, StaticERC1155, StaticUtil {\r\n\r\n    string public constant name = \"Wyvern Static\";\r\n\r\n    constructor (address atomicizerAddress)\r\n        public\r\n    {\r\n        atomicizer = atomicizerAddress;\r\n    }\r\n\r\n    function test () \r\n        public\r\n        pure\r\n    {\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/static/StaticERC20.sol": {
      "content": "/*\r\n\r\n    StaticERC20 - static calls for ERC20 trades\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\r\n\r\nimport \"../lib/ArrayUtils.sol\";\r\nimport \"../registry/AuthenticatedProxy.sol\";\r\n\r\ncontract StaticERC20 {\r\n\r\n    function transferERC20Exact(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory,\r\n        bytes memory data)\r\n        public\r\n        pure\r\n    {\r\n        // Decode extradata\r\n        (address token, uint amount) = abi.decode(extra, (address, uint));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == token);\r\n        // Call type = call\r\n        require(howToCall == AuthenticatedProxy.HowToCall.Call);\r\n        // Assert calldata\r\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], amount)));\r\n    }\r\n\r\n    function swapExact(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n        bytes memory data, bytes memory counterdata)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // Zero-value\r\n        require(uints[0] == 0);\r\n\r\n        // Decode extradata\r\n        (address[2] memory tokenGiveGet, uint[2] memory amountGiveGet) = abi.decode(extra, (address[2], uint[2]));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == tokenGiveGet[0]);\r\n        // Call type = call\r\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call);\r\n        // Assert calldata\r\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], amountGiveGet[0])));\r\n\r\n        require(addresses[5] == tokenGiveGet[1]);\r\n        // Countercall type = call\r\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call);\r\n        // Assert countercalldata\r\n        require(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[4], addresses[1], amountGiveGet[1])));\r\n\r\n        // Mark filled.\r\n        return 1;\r\n    }\r\n\r\n    function swapForever(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n        bytes memory data, bytes memory counterdata)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // Calculate function signature\r\n        bytes memory sig = ArrayUtils.arrayTake(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\"), 4);\r\n\r\n        // Zero-value\r\n        require(uints[0] == 0);\r\n\r\n        // Decode extradata\r\n        (address[2] memory tokenGiveGet, uint[2] memory numeratorDenominator) = abi.decode(extra, (address[2], uint[2]));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == tokenGiveGet[0]);\r\n        // Call type = call\r\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call);\r\n        // Check signature\r\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(data, 4)));\r\n        // Decode calldata\r\n        (address callFrom, address callTo, uint256 amountGive) = abi.decode(ArrayUtils.arrayDrop(data, 4), (address, address, uint256));\r\n        // Assert from\r\n        require(callFrom == addresses[1]);\r\n        // Assert to\r\n        require(callTo == addresses[4]);\r\n\r\n        // Countercall target = token to get\r\n        require(addresses[5] == tokenGiveGet[1]);\r\n        // Countercall type = call\r\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call);\r\n        // Check signature\r\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(counterdata, 4)));\r\n        // Decode countercalldata\r\n        (address countercallFrom, address countercallTo, uint256 amountGet) = abi.decode(ArrayUtils.arrayDrop(counterdata, 4), (address, address, uint256));\r\n        // Assert from\r\n        require(countercallFrom == addresses[4]);\r\n        // Assert to\r\n        require(countercallTo == addresses[1]);\r\n\r\n        // Assert ratio\r\n        // ratio = min get/give\r\n        require(SafeMath.mul(amountGet, numeratorDenominator[1]) >= SafeMath.mul(amountGive, numeratorDenominator[0]));\r\n\r\n        // Order will be set with maximumFill = 2 (to allow signature caching)\r\n        return 1;\r\n    }\r\n\r\n\r\n}\r\n"
    },
    "contracts/static/StaticERC1155.sol": {
      "content": "/*\r\n\r\nStaticERC1155 - static calls for ERC1155 trades\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\r\n\r\nimport \"../lib/ArrayUtils.sol\";\r\nimport \"../registry/AuthenticatedProxy.sol\";\r\n\r\ncontract StaticERC1155 {\r\n\r\nfunction transferERC1155Exact(bytes memory extra,\r\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory,\r\n\tbytes memory data)\r\n\tpublic\r\n\tpure\r\n{\r\n\t// Decode extradata\r\n\t(address token, uint256 tokenId, uint256 amount) = abi.decode(extra, (address, uint256, uint256));\r\n\r\n\t// Call target = token to give\r\n\trequire(addresses[2] == token);\r\n\t// Call type = call\r\n\trequire(howToCall == AuthenticatedProxy.HowToCall.Call);\r\n\t// Assert calldata\r\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], tokenId, amount, \"\")));\r\n}\r\n\r\nfunction swapOneForOneERC1155(bytes memory extra,\r\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n\tbytes memory data, bytes memory counterdata)\r\n\tpublic\r\n\tpure\r\n\treturns (uint)\r\n{\r\n\t// Zero-value\r\n\trequire(uints[0] == 0);\r\n\r\n\t// Decode extradata\r\n\t(address[2] memory tokenGiveGet, uint256[2] memory nftGiveGet, uint256[2] memory nftAmounts) = abi.decode(extra, (address[2], uint256[2], uint256[2]));\r\n\r\n\t// Call target = token to give\r\n\trequire(addresses[2] == tokenGiveGet[0], \"ERC1155: call target must equal address of token to give\");\r\n\t// Assert more than zero\r\n\trequire(nftAmounts[0] > 0,\"ERC1155: give amount must be larger than zero\");\r\n\t// Call type = call\r\n\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC1155: call must be a direct call\");\r\n\t// Assert calldata\r\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], nftGiveGet[0], nftAmounts[0], \"\")));\r\n\r\n\t// Countercall target = token to get\r\n\trequire(addresses[5] == tokenGiveGet[1], \"ERC1155: countercall target must equal address of token to get\");\r\n\t// Assert more than zero\r\n\trequire(nftAmounts[1] > 0,\"ERC1155: take amount must be larger than zero\");\r\n\t// Countercall type = call\r\n\trequire(howToCalls[1] == AuthenticatedProxy.HowToCall.Call, \"ERC1155: countercall must be a direct call\");\r\n\t// Assert countercalldata\r\n\trequire(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[4], addresses[1], nftGiveGet[1], nftAmounts[1], \"\")));\r\n\r\n\t// Mark filled\r\n\treturn 1;\r\n}\r\n\r\nfunction swapOneForOneERC1155Decoding(bytes memory extra,\r\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n\tbytes memory data, bytes memory counterdata)\r\n\tpublic\r\n\tpure\r\n\treturns (uint)\r\n{\r\n\t// Calculate function signature\r\n\tbytes memory sig = ArrayUtils.arrayTake(abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\"), 4);\r\n\r\n\t// Zero-value\r\n\trequire(uints[0] == 0);\r\n\r\n\t// Decode extradata\r\n\t(address[2] memory tokenGiveGet, uint256[2] memory nftGiveGet, uint256[2] memory nftAmounts) = abi.decode(extra, (address[2],uint256[2],uint256[2]));\r\n\r\n\t// Call target = token to give\r\n\trequire(addresses[2] == tokenGiveGet[0], \"ERC1155: call target must equal address of token to give\");\r\n\t// Call type = call\r\n\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC1155: call must be a direct call\");\r\n\t// Assert signature\r\n\trequire(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(data, 4)));\r\n\t// Decode and assert calldata\t\r\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], nftGiveGet[0], nftAmounts[0], \"\")));\r\n\t// Decode and assert countercalldata\r\n\trequire(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[4], addresses[1], nftGiveGet[1], nftAmounts[1], \"\")));\r\n\r\n\t// Mark filled\r\n\treturn 1;\r\n}\r\n\r\n}\r\n"
    },
    "contracts/static/StaticUtil.sol": {
      "content": "/*\r\n\r\n    StaticUtil - static call utility contract\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"../lib/StaticCaller.sol\";\r\nimport \"../lib/ArrayUtils.sol\";\r\nimport \"../registry/AuthenticatedProxy.sol\";\r\n\r\ncontract StaticUtil is StaticCaller {\r\n\r\n    address public atomicizer;\r\n\r\n    function any(bytes memory, address[7] memory, AuthenticatedProxy.HowToCall[2] memory, uint[6] memory, bytes memory, bytes memory)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        /*\r\n           Accept any call.\r\n           Useful e.g. for matching-by-transaction, where you authorize the counter-call by sending the transaction and don't need to re-check it.\r\n           Return fill \"1\".\r\n        */\r\n\r\n        return 1;\r\n    }\r\n\r\n    function anySingle(bytes memory,  address[7] memory, AuthenticatedProxy.HowToCall, uint[6] memory, bytes memory)\r\n        public\r\n        pure\r\n    {\r\n        /* No checks. */\r\n    }\r\n\r\n    function anyNoFill(bytes memory, address[7] memory, AuthenticatedProxy.HowToCall[2] memory, uint[6] memory, bytes memory, bytes memory)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        /*\r\n           Accept any call.\r\n           Useful e.g. for matching-by-transaction, where you authorize the counter-call by sending the transaction and don't need to re-check it.\r\n           Return fill \"0\".\r\n        */\r\n\r\n        return 0;\r\n    }\r\n\r\n    function anyAddOne(bytes memory, address[7] memory, AuthenticatedProxy.HowToCall[2] memory, uint[6] memory uints, bytes memory, bytes memory)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        /*\r\n           Accept any call.\r\n           Useful e.g. for matching-by-transaction, where you authorize the counter-call by sending the transaction and don't need to re-check it.\r\n           Return the current fill plus 1.\r\n        */\r\n\r\n        return uints[5] + 1;\r\n    }\r\n\r\n    function split(bytes memory extra,\r\n                   address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n                   bytes memory data, bytes memory counterdata)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        (address[2] memory targets, bytes4[2] memory selectors, bytes memory firstExtradata, bytes memory secondExtradata) = abi.decode(extra, (address[2], bytes4[2], bytes, bytes));\r\n\r\n        /* Split into two static calls: one for the call, one for the counter-call, both with metadata. */\r\n\r\n        /* Static call to check the call. */\r\n        require(staticCall(targets[0], abi.encodeWithSelector(selectors[0], firstExtradata, addresses, howToCalls[0], uints, data)));\r\n\r\n        /* Static call to check the counter-call. */\r\n        require(staticCall(targets[1], abi.encodeWithSelector(selectors[1], secondExtradata, [addresses[3], addresses[4], addresses[5], addresses[0], addresses[1], addresses[2], addresses[6]], howToCalls[1], uints, counterdata)));\r\n\r\n        return 1;\r\n    }\r\n\r\n    function splitAddOne(bytes memory extra,\r\n                   address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n                   bytes memory data, bytes memory counterdata)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        split(extra,addresses,howToCalls,uints,data,counterdata);\r\n        return uints[5] + 1;\r\n    }\r\n\r\n    function and(bytes memory extra,\r\n                 address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n                 bytes memory data, bytes memory counterdata)\r\n        public\r\n        view\r\n    {\r\n        (address[] memory addrs, bytes4[] memory selectors, uint[] memory extradataLengths, bytes memory extradatas) = abi.decode(extra, (address[], bytes4[], uint[], bytes));\r\n\r\n        require(addrs.length == extradataLengths.length);\r\n        \r\n        uint j = 0;\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            bytes memory extradata = new bytes(extradataLengths[i]);\r\n            for (uint k = 0; k < extradataLengths[i]; k++) {\r\n                extradata[k] = extradatas[j];\r\n                j++;\r\n            }\r\n            require(staticCall(addrs[i], abi.encodeWithSelector(selectors[i], extradata, addresses, howToCalls, uints, data, counterdata)));\r\n        }\r\n    }\r\n\r\n    function or(bytes memory extra,\r\n                address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n                bytes memory data, bytes memory counterdata)\r\n        public\r\n        view\r\n    {\r\n        (address[] memory addrs, bytes4[] memory selectors, uint[] memory extradataLengths, bytes memory extradatas) = abi.decode(extra, (address[], bytes4[], uint[], bytes));\r\n\r\n        require(addrs.length == extradataLengths.length, \"Different number of static call addresses and extradatas\");\r\n        \r\n        uint j = 0;\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            bytes memory extradata = new bytes(extradataLengths[i]);\r\n            for (uint k = 0; k < extradataLengths[i]; k++) {\r\n                extradata[k] = extradatas[j];\r\n                j++;\r\n            }\r\n            if (staticCall(addrs[i], abi.encodeWithSelector(selectors[i], extradata, addresses, howToCalls, uints, data, counterdata))) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        revert(\"No static calls succeeded\");\r\n    }\r\n\r\n    function sequenceExact(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory uints,\r\n        bytes memory cdata)\r\n        public\r\n        view\r\n    {\r\n        (address[] memory addrs, uint[] memory extradataLengths, bytes4[] memory selectors, bytes memory extradatas) = abi.decode(extra, (address[], uint[], bytes4[], bytes));\r\n\r\n        /* Assert DELEGATECALL to atomicizer library with given call sequence, split up predicates accordingly.\r\n           e.g. transferring two CryptoKitties in sequence. */\r\n\r\n        require(addrs.length == extradataLengths.length);\r\n\r\n        (address[] memory caddrs, uint[] memory cvals, uint[] memory clengths, bytes memory calldatas) = abi.decode(ArrayUtils.arrayDrop(cdata, 4), (address[], uint[], uint[], bytes));\r\n\r\n        require(addresses[2] == atomicizer);\r\n        require(howToCall == AuthenticatedProxy.HowToCall.DelegateCall);\r\n        require(addrs.length == caddrs.length); // Exact calls only\r\n\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            require(cvals[i] == 0);\r\n        }\r\n\r\n        sequence(caddrs, clengths, calldatas, addresses, uints, addrs, extradataLengths, selectors, extradatas);\r\n    }\r\n\r\n    function dumbSequenceExact(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n        bytes memory cdata, bytes memory)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        sequenceExact(extra, addresses, howToCalls[0], uints, cdata);\r\n\r\n        return 1;\r\n    }\r\n\r\n    function sequenceAnyAfter(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory uints,\r\n        bytes memory cdata)\r\n        public\r\n        view\r\n    {\r\n        (address[] memory addrs, uint[] memory extradataLengths, bytes4[] memory selectors, bytes memory extradatas) = abi.decode(extra, (address[], uint[], bytes4[], bytes));\r\n\r\n        /* Assert DELEGATECALL to atomicizer library with given call sequence, split up predicates accordingly.\r\n           e.g. transferring two CryptoKitties in sequence. */\r\n\r\n        require(addrs.length == extradataLengths.length);\r\n\r\n        (address[] memory caddrs, uint[] memory cvals, uint[] memory clengths, bytes memory calldatas) = abi.decode(ArrayUtils.arrayDrop(cdata, 4), (address[], uint[], uint[], bytes));\r\n\r\n        require(addresses[2] == atomicizer);\r\n        require(howToCall == AuthenticatedProxy.HowToCall.DelegateCall);\r\n        require(addrs.length <= caddrs.length); // Extra calls OK\r\n\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            require(cvals[i] == 0);\r\n        }\r\n\r\n        sequence(caddrs, clengths, calldatas, addresses, uints, addrs, extradataLengths, selectors, extradatas);\r\n    }\r\n\r\n    function sequence(\r\n        address[] memory caddrs, uint[] memory clengths, bytes memory calldatas,\r\n        address[7] memory addresses, uint[6] memory uints,\r\n        address[] memory addrs, uint[] memory extradataLengths, bytes4[] memory selectors, bytes memory extradatas)\r\n        internal\r\n        view\r\n    {\r\n        uint j = 0;\r\n        uint l = 0;\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            bytes memory extradata = new bytes(extradataLengths[i]);\r\n            for (uint k = 0; k < extradataLengths[i]; k++) {\r\n                extradata[k] = extradatas[j];\r\n                j++;\r\n            }\r\n            bytes memory data = new bytes(clengths[i]);\r\n            for (uint m = 0; m < clengths[i]; m++) {\r\n                data[m] = calldatas[l];\r\n                l++;\r\n            }\r\n            addresses[2] = caddrs[i];\r\n            require(staticCall(addrs[i], abi.encodeWithSelector(selectors[i], extradata, addresses, AuthenticatedProxy.HowToCall.Call, uints, data)));\r\n        }\r\n        require(j == extradatas.length);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/WyvernRegistry.sol": {
      "content": "/*\r\n\r\n  << Wyvern Proxy Registry >>\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"./registry/ProxyRegistry.sol\";\r\nimport \"./registry/AuthenticatedProxy.sol\";\r\n\r\n/**\r\n * @title WyvernRegistry\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract WyvernRegistry is ProxyRegistry {\r\n\r\n    string public constant name = \"Wyvern Protocol Proxy Registry\";\r\n\r\n    /* Whether the initial auth address has been set. */\r\n    bool public initialAddressSet = false;\r\n\r\n    constructor ()\r\n        public\r\n    {   \r\n        AuthenticatedProxy impl = new AuthenticatedProxy();\r\n        impl.initialize(address(this), this);\r\n        impl.setRevoke(true);\r\n        delegateProxyImplementation = address(impl);\r\n    }   \r\n\r\n    /** \r\n     * Grant authentication to the initial Exchange protocol contract\r\n     *\r\n     * @dev No delay, can only be called once - after that the standard registry process with a delay must be used\r\n     * @param authAddress Address of the contract to grant authentication\r\n     */\r\n    function grantInitialAuthentication (address authAddress)\r\n        onlyOwner\r\n        public\r\n    {   \r\n        require(!initialAddressSet, \"Wyvern Protocol Proxy Registry initial address already set\");\r\n        initialAddressSet = true;\r\n        contracts[authAddress] = true;\r\n    }   \r\n\r\n}\r\n"
    },
    "contracts/StaticMarket.sol": {
      "content": "/*\r\n\r\n  << Static Market contract >>\r\n\r\n*/\r\n\r\npragma solidity 0.7.5;\r\n\r\nimport \"./lib/ArrayUtils.sol\";\r\nimport \"./registry/AuthenticatedProxy.sol\";\r\n\r\n/**\r\n * @title StaticMarket\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract StaticMarket {\r\n\r\n\tstring public constant name = \"Static Market\";\r\n\r\n\tconstructor ()\r\n\t\tpublic\r\n\t{}\r\n\r\n\tfunction anyERC1155ForERC20(bytes memory extra,\r\n\t\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n\t\tbytes memory data, bytes memory counterdata)\r\n\t\tpublic\r\n\t\tpure\r\n\t\treturns (uint)\r\n\t{\r\n\t\trequire(uints[0] == 0,\"anyERC1155ForERC20: Zero value required\");\r\n\t\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"anyERC1155ForERC20: call must be a direct call\");\r\n\r\n\t\t(address[2] memory tokenGiveGet, uint256[3] memory tokenIdAndNumeratorDenominator) = abi.decode(extra, (address[2], uint256[3]));\r\n\r\n\t\trequire(tokenIdAndNumeratorDenominator[1] > 0,\"anyERC20ForERC1155: numerator must be larger than zero\");\r\n\t\trequire(tokenIdAndNumeratorDenominator[2] > 0,\"anyERC20ForERC1155: denominator must be larger than zero\");\r\n\t\trequire(addresses[2] == tokenGiveGet[0], \"anyERC1155ForERC20: call target must equal address of token to give\");\r\n\t\trequire(addresses[5] == tokenGiveGet[1], \"anyERC1155ForERC20: countercall target must equal address of token to get\");\r\n\r\n\t\tuint256[2] memory call_amounts = [\r\n\t\t\tgetERC1155AmountFromCalldata(data),\r\n\t\t\tgetERC20AmountFromCalldata(counterdata)\r\n\t\t];\r\n\t\tuint256 new_fill = SafeMath.add(uints[5],call_amounts[0]);\r\n\t\trequire(new_fill <= uints[1],\"anyERC1155ForERC20: new fill exceeds maximum fill\");\r\n\t\trequire(SafeMath.mul(tokenIdAndNumeratorDenominator[1], call_amounts[1]) == SafeMath.mul(tokenIdAndNumeratorDenominator[2], call_amounts[0]),\"anyERC1155ForERC20: wrong ratio\");\r\n\t\tcheckERC1155Side(data,addresses[1],addresses[4],tokenIdAndNumeratorDenominator[0],call_amounts[0]);\r\n\t\tcheckERC20Side(counterdata,addresses[4],addresses[1],call_amounts[1]);\r\n\t\t\r\n\t\treturn new_fill;\r\n\t}\r\n\r\n\tfunction anyERC20ForERC1155(bytes memory extra,\r\n\t\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n\t\tbytes memory data, bytes memory counterdata)\r\n\t\tpublic\r\n\t\tpure\r\n\t\treturns (uint)\r\n\t{\r\n\t\trequire(uints[0] == 0,\"anyERC20ForERC1155: Zero value required\");\r\n\t\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"anyERC20ForERC1155: call must be a direct call\");\r\n\r\n\t\t(address[2] memory tokenGiveGet, uint256[3] memory tokenIdAndNumeratorDenominator) = abi.decode(extra, (address[2], uint256[3]));\r\n\r\n\t\trequire(tokenIdAndNumeratorDenominator[1] > 0,\"anyERC20ForERC1155: numerator must be larger than zero\");\r\n\t\trequire(tokenIdAndNumeratorDenominator[2] > 0,\"anyERC20ForERC1155: denominator must be larger than zero\");\r\n\t\trequire(addresses[2] == tokenGiveGet[0], \"anyERC20ForERC1155: call target must equal address of token to get\");\r\n\t\trequire(addresses[5] == tokenGiveGet[1], \"anyERC20ForERC1155: countercall target must equal address of token to give\");\r\n\r\n\t\tuint256[2] memory call_amounts = [\r\n\t\t\tgetERC1155AmountFromCalldata(counterdata),\r\n\t\t\tgetERC20AmountFromCalldata(data)\r\n\t\t];\r\n\t\tuint256 new_fill = SafeMath.add(uints[5],call_amounts[1]);\r\n\t\trequire(new_fill <= uints[1],\"anyERC20ForERC1155: new fill exceeds maximum fill\");\r\n\t\trequire(SafeMath.mul(tokenIdAndNumeratorDenominator[1], call_amounts[0]) == SafeMath.mul(tokenIdAndNumeratorDenominator[2], call_amounts[1]),\"anyERC20ForERC1155: wrong ratio\");\r\n\t\tcheckERC1155Side(counterdata,addresses[4],addresses[1],tokenIdAndNumeratorDenominator[0],call_amounts[0]);\r\n\t\tcheckERC20Side(data,addresses[1],addresses[4],call_amounts[1]);\r\n\t\t\r\n\t\treturn new_fill;\r\n\t}\r\n\r\n\tfunction anyERC20ForERC20(bytes memory extra,\r\n\t\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n\t\tbytes memory data, bytes memory counterdata)\r\n\t\tpublic\r\n\t\tpure\r\n\t\treturns (uint)\r\n\t{\r\n\t\trequire(uints[0] == 0,\"anyERC20ForERC20: Zero value required\");\r\n\t\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"anyERC20ForERC20: call must be a direct call\");\r\n\r\n\t\t(address[2] memory tokenGiveGet, uint256[2] memory numeratorDenominator) = abi.decode(extra, (address[2], uint256[2]));\r\n\r\n\t\trequire(numeratorDenominator[0] > 0,\"anyERC20ForERC20: numerator must be larger than zero\");\r\n\t\trequire(numeratorDenominator[1] > 0,\"anyERC20ForERC20: denominator must be larger than zero\");\r\n\t\trequire(addresses[2] == tokenGiveGet[0], \"anyERC20ForERC20: call target must equal address of token to give\");\r\n\t\trequire(addresses[5] == tokenGiveGet[1], \"anyERC20ForERC20: countercall target must equal address of token to get\");\r\n\t\t\r\n\t\tuint256[2] memory call_amounts = [\r\n\t\t\tgetERC20AmountFromCalldata(data),\r\n\t\t\tgetERC20AmountFromCalldata(counterdata)\r\n\t\t];\r\n\t\tuint256 new_fill = SafeMath.add(uints[5],call_amounts[0]);\r\n\t\trequire(new_fill <= uints[1],\"anyERC20ForERC20: new fill exceeds maximum fill\");\r\n\t\trequire(SafeMath.mul(numeratorDenominator[0],call_amounts[0]) == SafeMath.mul(numeratorDenominator[1],call_amounts[1]),\"anyERC20ForERC20: wrong ratio\");\r\n\t\tcheckERC20Side(data,addresses[1],addresses[4],call_amounts[0]);\r\n\t\tcheckERC20Side(counterdata,addresses[4],addresses[1],call_amounts[1]);\r\n\t\t\r\n\t\treturn new_fill;\r\n\t}\r\n\r\n\tfunction ERC721ForERC20(bytes memory extra,\r\n\t\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n\t\tbytes memory data, bytes memory counterdata)\r\n\t\tpublic\r\n\t\tpure\r\n\t\treturns (uint)\r\n\t{\r\n\t\trequire(uints[0] == 0,\"ERC721ForERC20: Zero value required\");\r\n\t\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC721ForERC20: call must be a direct call\");\r\n\r\n\t\t(address[2] memory tokenGiveGet, uint256[2] memory tokenIdAndPrice) = abi.decode(extra, (address[2], uint256[2]));\r\n\r\n\t\trequire(tokenIdAndPrice[1] > 0,\"ERC721ForERC20: ERC721 price must be larger than zero\");\r\n\t\trequire(addresses[2] == tokenGiveGet[0], \"ERC721ForERC20: call target must equal address of token to give\");\r\n\t\trequire(addresses[5] == tokenGiveGet[1], \"ERC721ForERC20: countercall target must equal address of token to get\");\r\n\r\n\t\tcheckERC721Side(data,addresses[1],addresses[4],tokenIdAndPrice[0]);\r\n\t\tcheckERC20Side(counterdata,addresses[4],addresses[1],tokenIdAndPrice[1]);\r\n\t\t\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tfunction ERC20ForERC721(bytes memory extra,\r\n\t\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n\t\tbytes memory data, bytes memory counterdata)\r\n\t\tpublic\r\n\t\tpure\r\n\t\treturns (uint)\r\n\t{\r\n\t\trequire(uints[0] == 0,\"ERC20ForERC721: Zero value required\");\r\n\t\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC20ForERC721: call must be a direct call\");\r\n\r\n\t\t(address[2] memory tokenGiveGet, uint256[2] memory tokenIdAndPrice) = abi.decode(extra, (address[2], uint256[2]));\r\n\r\n\t\trequire(tokenIdAndPrice[1] > 0,\"ERC20ForERC721: ERC721 price must be larger than zero\");\r\n\t\trequire(addresses[2] == tokenGiveGet[0], \"ERC20ForERC721: call target must equal address of token to give\");\r\n\t\trequire(addresses[5] == tokenGiveGet[1], \"ERC20ForERC721: countercall target must equal address of token to get\");\r\n\r\n\t\tcheckERC721Side(counterdata,addresses[4],addresses[1],tokenIdAndPrice[0]);\r\n\t\tcheckERC20Side(data,addresses[1],addresses[4],tokenIdAndPrice[1]);\r\n\t\t\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tfunction getERC1155AmountFromCalldata(bytes memory data)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (uint256)\r\n\t{\r\n\t\t(uint256 amount) = abi.decode(ArrayUtils.arraySlice(data,100,32),(uint256));\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction getERC20AmountFromCalldata(bytes memory data)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (uint256)\r\n\t{\r\n\t\t(uint256 amount) = abi.decode(ArrayUtils.arraySlice(data,68,32),(uint256));\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction checkERC1155Side(bytes memory data, address from, address to, uint256 tokenId, uint256 amount)\r\n\t\tinternal\r\n\t\tpure\r\n\t{\r\n\t\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", from, to, tokenId, amount, \"\")));\r\n\t}\r\n\r\n\tfunction checkERC721Side(bytes memory data, address from, address to, uint256 tokenId)\r\n\t\tinternal\r\n\t\tpure\r\n\t{\r\n\t\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", from, to, tokenId)));\r\n\t}\r\n\r\n\tfunction checkERC20Side(bytes memory data, address from, address to, uint256 amount)\r\n\t\tinternal\r\n\t\tpure\r\n\t{\r\n\t\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", from, to, amount)));\r\n\t}\r\n}\r\n"
    },
    "contracts/TierX.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\r\npragma solidity 0.7.5;\r\n\r\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract TierX is ERC20 {\r\n  constructor() ERC20(\"TierX\", \"TRX\") {\r\n    _mint(msg.sender, 1_000 * (10**18)); // Mint 1k to owner\r\n  }\r\n\r\n  function mint(uint256 quantity) external payable {\r\n    _mint(msg.sender, quantity);\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}